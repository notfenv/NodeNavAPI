"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[177],{88565:t=>{t.exports=JSON.parse('{"functions":[{"name":"Get","desc":"Returns the current node navigator, if there is one.","params":[],"returns":[{"desc":"The current navigator.","lua_type":"NodeNavigator"}],"function_type":"static","source":{"line":125,"path":"lib/init.luau"}},{"name":"Create","desc":"Constructs a new node navigator.\\n\\n:::tip\\nIf a navigator already exists, this will return the existing navigator unless `replaceCurrentNavigator` is `true`,\\nin which it will replace the current navigator with the new one.\\n:::","params":[{"name":"nodeGraph","desc":"The node graph to use. If it\'s a folder, it\'s considered a workspace node graph.","lua_type":"Folder"},{"name":"replaceCurrentNavigator","desc":"If this navigator will replace the current navigator.","lua_type":"boolean?"}],"returns":[{"desc":"The new navigator.","lua_type":"NodeNodeNavigator"}],"function_type":"static","source":{"line":145,"path":"lib/init.luau"}}],"properties":[],"types":[],"name":"NodeNavigator","desc":"Allows for the parsing and traversing of node graphs.\\nOriginally made by Gnat ([@treebee63](https://www.roblox.com/users/9735417/profile)), revisions/revamp by Mia ([@notawildfox](https://www.roblox.com/users/124963457/profile))\\n\\nHere is how you can create a simple pathfinding loop:\\n```lua\\nlocal Navigator = require(path.to.Navigator)\\n\\nlocal Navigator = Navigator.Get() or Navigator.Create(game.ServerStorage.NodeGraph) -- Assuming a navigator was already made, or a nodegraph exists somewhere\\n\\nlocal Character = script.Parent\\nlocal RootPart = Character.HumanoidRootPart\\nlocal Humanoid = Character.Humanoid\\n\\nlocal pathId = 0\\n\\nlocal function RunPath(targetPosition: Vector3): ()\\n\\t-- Compute the path\\n\\tNavigator:TryComputePath(RootPart.Position, targetPosition)\\n\\t\\t:andThen(function(path)\\n\\t\\t\\t-- Because we\'re recomputing every second, we need some sort of way\\n\\t\\t\\t-- to cancel the current path.\\n\\t\\t\\tpathId += 1\\n\\t\\t\\tlocal myPath = pathId\\n\\n\\t\\t\\t-- Make humanoid traverse along path\\n\\t\\t\\tfor _,waypoint in path:GetWaypoints() do\\n\\t\\t\\t\\tif pathId ~= myPath then continue end -- This path got cancelled\\n\\t\\t\\t\\tif waypoint.Action == Enum.PathWaypointAction.Jump then\\n\\t\\t\\t\\t\\t-- Hit a jump connector, force the Humanoid to jump\\n\\t\\t\\t\\t\\tHumanoid:ChangeState(Enum.HumanoidStateType.Jumping)\\n\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\tHumanoid:MoveTo(waypoint.Position)\\n\\t\\t\\t\\tHumanoid.MoveToFinished:Wait()\\n\\n\\t\\t\\t\\t-- We reached the waypoint, move on\\n\\t\\t\\tend\\n\\t\\tend)\\n\\t\\t:catch(function(err)\\n\\t\\t\\t-- Computation must\'ve failed, lets see where we went wrong\\n\\t\\t\\twarn(err)\\n\\t\\tend)\\n\\n\\t-- NOTE: You can also use different algorithms for pathfinding:\\n\\t-- Navigator:TryComputePath(RootPart.Position, targetPosition, 10, \\"Dijkstra\\")\\n\\t-- Navigator:TryComputePath(RootPart.Position, targetPosition, 10, \\"BFS\\")\\n\\t-- The \\"10\\" param specifies the maximum start/target node query distance, smaller numbers are usually more optimal.\\nend\\n\\nwhile true do\\n\\tRunPath(workspace.TargetBlock.Position) -- Assuming you have a part called `TargetBlock` in the `Workspace`\\n\\ttask.wait(1)\\nend\\n\\n```","source":{"line":118,"path":"lib/init.luau"}}')}}]);