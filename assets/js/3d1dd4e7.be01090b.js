"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[177],{88565:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new navigator for nodegraphs.\\n\\nIf a navigator already exists, this will return\\nthe current node navigator.","params":[],"returns":[{"desc":"The new navigator.","lua_type":"NodeNavigator"}],"function_type":"static","source":{"line":125,"path":"lib/init.luau"}},{"name":"Parse","desc":"Changes the navigator\'s graph, rebuilding the grid.","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"nodeGraph","desc":"The new node graph.","lua_type":"NodeGraph"}],"returns":[],"function_type":"static","source":{"line":150,"path":"lib/init.luau"}},{"name":"TryComputePath","desc":"Tries to calculate a path from `startPoint` to `targetPoint`.\\n\\nIf there is no feasible path from `startPoint` to `targetPoint`, this function\\nwill return `nil`.","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"startPoint","desc":"The pathfinding origin.","lua_type":"Vector3"},{"name":"targetPoint","desc":"The pathfinding destination.","lua_type":"Vector3"},{"name":"maxNodeDist","desc":"The longest sightline to the nearest node the bot will try and find (Leave nil to default to 100)","lua_type":"number?"},{"name":"algorithm","desc":"Whether to use A* algorithm, Dijkstra\'s algorithm, Breadth-First Search algorithm, or Greedy Best First Search algorithm for pathfinding. (Leave nil to default to \\"AStar\\")","lua_type":"PathAlgorithm?"}],"returns":[{"desc":"The computed path object.","lua_type":"Promise<NavigatorPath>"}],"function_type":"static","errors":[{"lua_type":"\\"No network bound. Did you forget to call :Parse()?\\"","desc":"A node graph wasn\'t parsed."}],"source":{"line":185,"path":"lib/init.luau"}},{"name":"GetEdgeNear","desc":"Finds and returns the nearest edge to `position`.","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"position","desc":"Where to look for a nearby edge.","lua_type":"Vector3"},{"name":"maxRadius","desc":"The maximum distance to check for nearby edges. Default = 100","lua_type":"number?"},{"name":"filterFn","desc":"An optional edge-by-edge filtering function, where if the returned condition is false, that closest edge will not be considered.","lua_type":"(edge: Edge) -> boolean"}],"returns":[{"desc":"The nearest edge","lua_type":"Edge?"}],"function_type":"static","source":{"line":242,"path":"lib/init.luau"}},{"name":"GetEdgesInBox","desc":"Finds and returns the edges inside of a part or given bounds.\\n\\nThis is useful if you wish to disable pathfinding through obstructed areas, for example, debris.\\nExample Usage:\\n```lua\\nfor _,edge in Navigator:GetEdgesInBox(edgeDisableRegion) do\\n\\tedge.SetEnabled(false) -- Don\'t allow pathfinding through `edgeDisableRegion`\\nend\\n```","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"box","desc":"The param for spatial querying","lua_type":"BasePart | BoxParam"},{"name":"filterFn","desc":"An optional edge-by-edge filtering function, where if the returned condition is false, that in-box edge will not be appended.","lua_type":"(edge: Edge) -> boolean"}],"returns":[{"desc":"The edges in the specified box region","lua_type":"{ Edge }"}],"function_type":"static","source":{"line":281,"path":"lib/init.luau"}},{"name":"ConnectNodes","desc":"Bidirectionally connects two nodes with a specified connection type\\nIf the connection type is \\"OneWay,\\" the connection will only be unidirectional.","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"startNode","desc":"The starting node (the order doesn\'t matter UNLESS it\'s a one-way edge)","lua_type":"GraphNode"},{"name":"targetNode","desc":"The target node (the order doesn\'t matter UNLESS it\'s a one-way edge)","lua_type":"GraphNode"},{"name":"connectionType","desc":"The type of the connection.","lua_type":"\\"Edge\\" | \\"Jump\\" | \\"OneWay\\""},{"name":"isEnabled","desc":"An optional boolean that dictates if the edge is initially enabled or not.","lua_type":"boolean?"}],"returns":[{"desc":"The newly created edge (the main one. Toggling this edge will also toggle the entire edge bidirectionally)","lua_type":"Edge"}],"function_type":"static","errors":[{"lua_type":"\\"No network bound. Did you forget to call :Parse()?\\"","desc":"A node graph wasn\'t parsed."}],"source":{"line":320,"path":"lib/init.luau"}},{"name":"PlaceNodeAt","desc":"Creates a node at a position.","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"position","desc":"The position of the node.","lua_type":"Vector3"},{"name":"index","desc":"The index/name of the node. If not supplied, will use the next available node index.","lua_type":"string?"}],"returns":[{"desc":"The newly created node.","lua_type":"GraphNode"}],"function_type":"static","errors":[{"lua_type":"\\"No network bound. Did you forget to call :Parse()?\\"","desc":"A node graph wasn\'t parsed."}],"source":{"line":353,"path":"lib/init.luau"}},{"name":"GetNodeWithIndex","desc":"Finds a node with a specified index/name.","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"index","desc":"The index of the node to find","lua_type":"string"}],"returns":[{"desc":"The node with the matching index","lua_type":"GraphNode?"}],"function_type":"static","errors":[{"lua_type":"\\"No network bound. Did you forget to call :Parse()?\\"","desc":"A node graph wasn\'t parsed."},{"lua_type":"\\"Invalid index (expected string, got {X})\\"","desc":"Index MUST be a string."}],"source":{"line":381,"path":"lib/init.luau"}},{"name":"GetNodeNear","desc":"Finds and returns the nearest node to `position`.","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"position","desc":"Where to look for a nearby node.","lua_type":"Vector3"},{"name":"maxRadius","desc":"The maximum distance to check for nearby node. Default = 100","lua_type":"number?"},{"name":"filterFn","desc":"An optional node-by-node filtering function, where if the returned condition is false, that closest node will not be considered.","lua_type":"(node: GraphNode) -> boolean"}],"returns":[{"desc":"The nearest node","lua_type":"GraphNode?"}],"function_type":"static","source":{"line":400,"path":"lib/init.luau"}},{"name":"GetNodesInBox","desc":"Finds and returns the nodes inside of a part or given bounds.","params":[{"name":"self","desc":"","lua_type":"NodeNavigator"},{"name":"box","desc":"The param for spatial querying","lua_type":"BasePart | BoxParam"},{"name":"filterFn","desc":"An optional node-by-node filtering function, where if the returned condition is false, that in-box node will not be appended.","lua_type":"(node: GraphNode) -> boolean"}],"returns":[{"desc":"The nodes in the specified box region","lua_type":"{ GraphNode }"}],"function_type":"static","source":{"line":426,"path":"lib/init.luau"}}],"properties":[],"types":[],"name":"NodeNavigator","desc":"A node navigation class that allows for node pathfinding with various different pathfinding algorithms.\\nUsed with a graph/navigation network.\\n\\nUse `Navigator.OnGraphUpdated` to listen for whenever the graph is manipulated (example: an edge is toggled)\\n\\nHere is how you can create a simple pathfinding loop:\\n```lua\\nlocal NodeNavigator = require(path.to.NodeNavigator)\\n\\nlocal Navigator = NodeNavigator.Get() or NodeNavigator.Create(game.ServerStorage.NodeGraph) -- Assuming a navigator was already made, or a nodegraph exists somewhere\\n\\nlocal Character = script.Parent\\nlocal RootPart = Character.HumanoidRootPart\\nlocal Humanoid = Character.Humanoid\\n\\nlocal pathId = 0\\n\\nlocal function RunPath(targetPosition: Vector3): ()\\n\\t-- Compute the path\\n\\tNavigator:TryComputePath(RootPart.Position, targetPosition)\\n\\t\\t:andThen(function(path)\\n\\t\\t\\t-- Because we\'re recomputing every second, we need some sort of way\\n\\t\\t\\t-- to cancel the current path.\\n\\t\\t\\tpathId += 1\\n\\t\\t\\tlocal myPath = pathId\\n\\n\\t\\t\\t-- Make humanoid traverse along path\\n\\t\\t\\tfor _,waypoint in path:GetWaypoints() do\\n\\t\\t\\t\\tif pathId ~= myPath then continue end -- This path got cancelled\\n\\t\\t\\t\\tif waypoint.Action == Enum.PathWaypointAction.Jump then\\n\\t\\t\\t\\t\\t-- Hit a jump connector, force the Humanoid to jump\\n\\t\\t\\t\\t\\tHumanoid:ChangeState(Enum.HumanoidStateType.Jumping)\\n\\t\\t\\t\\tend\\n\\n\\t\\t\\t\\tHumanoid:MoveTo(waypoint.Position)\\n\\t\\t\\t\\tHumanoid.MoveToFinished:Wait()\\n\\n\\t\\t\\t\\t-- We reached the waypoint, move on\\n\\t\\t\\tend\\n\\t\\tend)\\n\\t\\t:catch(function(err)\\n\\t\\t\\t-- Computation must\'ve failed, lets see where we went wrong\\n\\t\\t\\twarn(err)\\n\\t\\tend)\\n\\n\\t-- NOTE: You can also use different algorithms for pathfinding:\\n\\t-- Navigator:TryComputePath(RootPart.Position, targetPosition, 10, \\"Dijkstra\\")\\n\\t-- Navigator:TryComputePath(RootPart.Position, targetPosition, 10, \\"BFS\\")\\n\\t-- The \\"10\\" param specifies the maximum start/target node query distance, smaller numbers are usually more optimal.\\nend\\n\\nwhile true do\\n\\tRunPath(workspace.TargetBlock.Position) -- Assuming you have a part called `TargetBlock` in the `Workspace`\\n\\ttask.wait(1)\\nend\\n\\n```\\n\\n\\"Nodes\\" are the points that the AI traverse to.\\n\\"Connectors\\" are the connections between Nodes, marking which nodes the AI\\n\\tcan go to, from the current Node.\\n\\nThere are currently three types of Node Connectors:\\n\\"Edge Connector\\" - A normal, bidirectional movement connector. Visualized as a line\\n\\n\\"Jump Connector\\" - A connector where if the AI has to traverse 2 nodes connected by a Jump Connector,\\n\\tthe AI should jump. Visualized as a spring.\\n\\n\\"One-Way Connector\\" - A connector where the AI can only move to it\'s target node in the direction of it\'s visual indicator,\\n\\tand not back. Visualized as a Beam with an arrows texture, where the direction of the arrows is the direction of movement.","source":{"line":113,"path":"lib/init.luau"}}')}}]);