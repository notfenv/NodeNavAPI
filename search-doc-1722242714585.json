[{"title":"Set Up / Basics","type":0,"sectionRef":"#","url":"/NodeNavAPI/docs/intro","content":"Set Up / Basics First you've gotta actually parse the nodegraph you want to use local NodeNavigator = require(path.to.NodeNavigator) local Navigator = NodeNavigator.Get() or NodeNavigator.Create(game.ServerStorage.NodeGraph) -- Assuming a navigator was already made, or a nodegraph exists somewhere Great, now you can start using the navigator To compute a path between two points, use the Navigator:TryComputePath(startPosition, targetPosition) method, which returns a Promise. You can then get the computed path via chaining :andThen(function(path)), or following the call with :expect() Example of both cases: andThen: Navigator:TryComputePath(pointA, pointB):andThen(function(path) -- We have the path end):catch(function(err) -- Safely exit due to an error, print it out if you want to see what went wrong. end) expect local path = Navigator:TryComputePath(pointA, pointB):expect() caution Should an exception occur with the :expect() method, it will invoke an error. Alternatively, you can use the :await() method and check if the operation was successful or not. local success, path = Navigator:TryComputePath(pointA, pointB):await() if success then -- Got path else -- Something went wrong end To get the waypoints of a path, simply call path:GetWaypoints(). This returns an ordered array of PathWaypoint objects, that you can use to make a humanoid follow along. In addition, you can also visualize the computed path by running path:Visualize(). Usage Guide With all of this in mind, here is how you can set up a simple pathfinding loop with a humanoid agent. local Character = script.Parent local RootPart = Character.HumanoidRootPart local Humanoid = Character.Humanoid local pathId = 0 local function RunPath(targetPosition: Vector3): () -- Compute the path Navigator:TryComputePath(RootPart.Position, targetPosition) :andThen(function(path) -- Because we're recomputing every second, we need some sort of way -- to cancel the current path. pathId += 1 local myPath = pathId -- Make humanoid traverse along path for _,waypoint in path:GetWaypoints() do if pathId ~= myPath then continue end -- This path got cancelled if waypoint.Action == Enum.PathWaypointAction.Jump then -- Hit a jump connector, force the Humanoid to jump Humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end Humanoid:MoveTo(waypoint.Position) Humanoid.MoveToFinished:Wait() -- We reached the waypoint, move on end end) :catch(function(err) -- Computation must've failed, lets see where we went wrong warn(err) end) -- NOTE: You can also use different algorithms for pathfinding: -- Navigator:TryComputePath(RootPart.Position, targetPosition, 10, &quot;Dijkstra&quot;) -- Navigator:TryComputePath(RootPart.Position, targetPosition, 10, &quot;BFS&quot;) -- The &quot;10&quot; param specifies the maximum start/target node query distance, smaller numbers are usually more optimal. end while true do RunPath(workspace.TargetBlock.Position) -- Assuming you have a part called `TargetBlock` in the `Workspace` task.wait(1) end ","keywords":""},{"title":"NodeNavigator","type":0,"sectionRef":"#","url":"/NodeNavAPI/api/NodeNavigator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#functions","content":" "},{"title":"new​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#new","content":"&lt;/&gt; NodeNavigator.new() → NodeNavigator-- The new navigator. Constructs a new navigator for nodegraphs. If a navigator already exists, this will return the current node navigator.  "},{"title":"Parse​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#Parse","content":"&lt;/&gt; NodeNavigator.Parse( self: NodeNavigator, nodeGraph: NodeGraph-- The new node graph. ) → () Changes the navigator's graph, rebuilding the grid.  "},{"title":"TryComputePath​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#TryComputePath","content":"&lt;/&gt; NodeNavigator.TryComputePath( self: NodeNavigator, startPoint: Vector3 ,-- The pathfinding origin. targetPoint: Vector3 ,-- The pathfinding destination. maxNodeDist: number?,-- The longest sightline to the nearest node the bot will try and find (Leave nil to default to 100) algorithm: PathAlgorithm?-- Whether to use A* algorithm, Dijkstra's algorithm, Breadth-First Search algorithm, or Greedy Best First Search algorithm for pathfinding. (Leave nil to default to &quot;AStar&quot;) ) → Promise&lt;NavigatorPath&gt;-- The computed path object. Tries to calculate a path from startPoint to targetPoint. If there is no feasible path from startPoint to targetPoint, this function will return nil. "},{"title":"Errors","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator##","content":"Type\tDescription&quot;No network bound. Did you forget to call :Parse()?&quot;\tA node graph wasn't parsed.  "},{"title":"GetEdgeNear​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#GetEdgeNear","content":"&lt;/&gt; NodeNavigator.GetEdgeNear( self: NodeNavigator, position: Vector3 ,-- Where to look for a nearby edge. maxRadius: number?,-- The maximum distance to check for nearby edges. Default = 100 filterFn: (edge: Edge) → boolean-- An optional edge-by-edge filtering function, where if the returned condition is false, that closest edge will not be considered. ) → Edge?-- The nearest edge Finds and returns the nearest edge to position.  "},{"title":"GetEdgesInBox​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#GetEdgesInBox","content":"&lt;/&gt; NodeNavigator.GetEdgesInBox( self: NodeNavigator, box: BasePart | BoxParam,-- The param for spatial querying filterFn: (edge: Edge) → boolean-- An optional edge-by-edge filtering function, where if the returned condition is false, that in-box edge will not be appended. ) → {Edge}-- The edges in the specified box region Finds and returns the edges inside of a part or given bounds. This is useful if you wish to disable pathfinding through obstructed areas, for example, debris. Example Usage: for _,edge in Navigator:GetEdgesInBox(edgeDisableRegion) do edge.SetEnabled(false) -- Don't allow pathfinding through `edgeDisableRegion` end   "},{"title":"ConnectNodes​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#ConnectNodes","content":"&lt;/&gt; NodeNavigator.ConnectNodes( self: NodeNavigator, startNode: GraphNode,-- The starting node (the order doesn't matter UNLESS it's a one-way edge) targetNode: GraphNode,-- The target node (the order doesn't matter UNLESS it's a one-way edge) connectionType: &quot;Edge&quot; | &quot;Jump&quot; | &quot;OneWay&quot;,-- The type of the connection. isEnabled: boolean?-- An optional boolean that dictates if the edge is initially enabled or not. ) → Edge-- The newly created edge (the main one. Toggling this edge will also toggle the entire edge bidirectionally) Bidirectionally connects two nodes with a specified connection type If the connection type is &quot;OneWay,&quot; the connection will only be unidirectional. "},{"title":"Errors","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator##","content":"Type\tDescription&quot;No network bound. Did you forget to call :Parse()?&quot;\tA node graph wasn't parsed.  "},{"title":"PlaceNodeAt​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#PlaceNodeAt","content":"&lt;/&gt; NodeNavigator.PlaceNodeAt( self: NodeNavigator, position: Vector3 ,-- The position of the node. index: string?-- The index/name of the node. If not supplied, will use the next available node index. ) → GraphNode-- The newly created node. Creates a node at a position. "},{"title":"Errors","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator##","content":"Type\tDescription&quot;No network bound. Did you forget to call :Parse()?&quot;\tA node graph wasn't parsed.  "},{"title":"GetNodeWithIndex​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#GetNodeWithIndex","content":"&lt;/&gt; NodeNavigator.GetNodeWithIndex( self: NodeNavigator, index: string-- The index of the node to find ) → GraphNode?-- The node with the matching index Finds a node with a specified index/name. "},{"title":"Errors","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator##","content":"Type\tDescription&quot;No network bound. Did you forget to call :Parse()?&quot;\tA node graph wasn't parsed. &quot;Invalid index (expected string, got {X})&quot;\tIndex MUST be a string.  "},{"title":"GetNodeNear​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#GetNodeNear","content":"&lt;/&gt; NodeNavigator.GetNodeNear( self: NodeNavigator, position: Vector3 ,-- Where to look for a nearby node. maxRadius: number?,-- The maximum distance to check for nearby node. Default = 100 filterFn: (node: GraphNode) → boolean-- An optional node-by-node filtering function, where if the returned condition is false, that closest node will not be considered. ) → GraphNode?-- The nearest node Finds and returns the nearest node to position.  "},{"title":"GetNodesInBox​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#GetNodesInBox","content":"&lt;/&gt; NodeNavigator.GetNodesInBox( self: NodeNavigator, box: BasePart | BoxParam,-- The param for spatial querying filterFn: (node: GraphNode) → boolean-- An optional node-by-node filtering function, where if the returned condition is false, that in-box node will not be appended. ) → {GraphNode}-- The nodes in the specified box region Finds and returns the nodes inside of a part or given bounds. "}]