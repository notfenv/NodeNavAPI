[{"title":"Intro","type":0,"sectionRef":"#","url":"/NodeNavAPI/docs/intro","content":"Intro Allows for the parsing and traversing of node graphs. Originally made by Gnat (@treebee63), revisions/revamp by Mia (@notawildfox) I heartily suggest using this in conjunction with Roblox pathfinding, as node graphs only really shine in indoors/close-quarters areas. Mia's Contributions: Complete revamp of the navigator, with additional features (such as the user being able to toggle edges in real-time for obstacles) Instead of only using Dijkstra's algorithm, adding multiple algorithms (including, but not limited to: A*, Dijkstra, BFS, GBFS) Full networker PLUGIN revamp Plans: Full real-time control of the node graph, this includes (but is not limited to): Node Control Changing node positionsCreating/removing nodes Edge control ✅ Edge querying and togglingEdge type manipulation (being able to switch edge types, like Jump or OneWay) Dynamic node graph quality Simply put, a way to auto adjust the graph's resolution, like subdividing the graph. Gnat dubbed this as &quot;fuzzy pathing, that improves the closer you are to the target&quot; It should speed up longer distance computation. Probably going to be chunk clustered and each cluster will be treated as one point ✅ Path caching Caching already exists, however, it's been disabled due to real-time controls. With this in mind, perhaps an integrity check with cached paths that checks if the nodes and connections are valid with the current node graph, otherwise, that cache can be invalidated and a new path may be computed.","keywords":""},{"title":"NavigatorPath","type":0,"sectionRef":"#","url":"/NodeNavAPI/api/NavigatorPath","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"NavigatorPath","url":"/NodeNavAPI/api/NavigatorPath#functions","content":" "},{"title":"new​","type":1,"pageTitle":"NavigatorPath","url":"/NodeNavAPI/api/NavigatorPath#new","content":"&lt;/&gt; NavigatorPath.new( waypoints: {PathWaypoint }-- The array of waypoints, aka the computed path. ) → NavigatorPath-- The new NavigatorPath object. Constructs a new path.  "},{"title":"GetWaypoints​","type":1,"pageTitle":"NavigatorPath","url":"/NodeNavAPI/api/NavigatorPath#GetWaypoints","content":"&lt;/&gt; NavigatorPath.GetWaypoints(self: NavigatorPath) → Path -- The waypoints in order, from start to finish. Returns the path's waypoints.  "},{"title":"Visualize​","type":1,"pageTitle":"NavigatorPath","url":"/NodeNavAPI/api/NavigatorPath#Visualize","content":"&lt;/&gt; NavigatorPath.Visualize( self: NavigatorPath, container: Instance? -- The container of the visualized path. Defaults to Workspace. ) → () Visualizes the path.  "},{"title":"ClearVisualizer​","type":1,"pageTitle":"NavigatorPath","url":"/NodeNavAPI/api/NavigatorPath#ClearVisualizer","content":"&lt;/&gt; NavigatorPath.ClearVisualizer(self: NavigatorPath) → () Clears the path visuals.  "},{"title":"Destroy​","type":1,"pageTitle":"NavigatorPath","url":"/NodeNavAPI/api/NavigatorPath#Destroy","content":"&lt;/&gt; NavigatorPath.Destroy(self: NavigatorPath) → () Destroys the path, clearing all data and visualizers. "},{"title":"NodeNavigator","type":0,"sectionRef":"#","url":"/NodeNavAPI/api/NodeNavigator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#functions","content":" "},{"title":"Get​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#Get","content":"&lt;/&gt; NodeNavigator.Get() → NodeNavigator-- The current navigator. Returns the current node navigator, if there is one.  "},{"title":"Create​","type":1,"pageTitle":"NodeNavigator","url":"/NodeNavAPI/api/NodeNavigator#Create","content":"&lt;/&gt; NodeNavigator.Create( nodeGraph: Folder ,-- The node graph to use. If it's a folder, it's considered a workspace node graph. replaceCurrentNavigator: boolean?-- If this navigator will replace the current navigator. ) → NodeNodeNavigator-- The new navigator. Constructs a new node navigator. tip If a navigator already exists, this will return the existing navigator unless replaceCurrentNavigator is true, in which it will replace the current navigator with the new one. "},{"title":"Set Up / Basics","type":0,"sectionRef":"#","url":"/NodeNavAPI/docs/Setup","content":"Set Up / Basics First you've gotta actually parse the nodegraph you want to use. When a nodegraph is parsed, it gives the Navigator information about the graph's nodes, connections (and their types) so that the algorithm has something to navigate with. tip People who come from using Roblox's pathfinding system tend to think that node-pathfinding will just go through walls or anything stupid of that nature. This is incorrect. Node-pathfinding, as the name implies, pathfinds based on a set of nodes, which means you place those nodes where YOU want your AI to go. Think of each node as a walk-to point. Edges define which nodes can go to other nodes. local NodeNavigator = require(path.to.NodeNavigator) local Navigator = NodeNavigator.Get() or NodeNavigator.Create(game.ServerStorage.NodeGraph) -- Assuming a navigator was already made, or a nodegraph exists somewhere Great, now you can start using the navigator To compute a path between two points, use the Navigator:TryComputePath(startPosition, targetPosition) method, which returns a Promise. You can then get the computed path via chaining :andThen(function(path)), or following the call with :expect() Example of both cases: andThen: Navigator:TryComputePath(pointA, pointB):andThen(function(path) -- We have the path end):catch(function(err) -- Safely exit due to an error, print it out if you want to see what went wrong. end) expect local path = Navigator:TryComputePath(pointA, pointB):expect() caution Should an exception occur with the :expect() method, it will invoke an error. Alternatively, you can use the :await() method and check if the operation was successful or not. local success, path = Navigator:TryComputePath(pointA, pointB):await() if success then -- Got path else -- Something went wrong end To get the waypoints of a path, simply call path:GetWaypoints(). This returns an ordered array of PathWaypoint objects, that you can use to make a humanoid follow along. In addition, you can also visualize the computed path by running path:Visualize(). Usage Guide With all of this in mind, here is how you can set up a simple pathfinding loop with a humanoid agent. local Character = script.Parent local RootPart = Character.HumanoidRootPart local Humanoid = Character.Humanoid local pathId = 0 local function RunPath(targetPosition: Vector3): () -- Compute the path Navigator:TryComputePath(RootPart.Position, targetPosition) :andThen(function(path) -- Because we're recomputing every second, we need some sort of way -- to cancel the current path. pathId += 1 local myPath = pathId -- Make humanoid traverse along path for _,waypoint in path:GetWaypoints() do if pathId ~= myPath then continue end -- This path got cancelled if waypoint.Action == Enum.PathWaypointAction.Jump then -- Hit a jump connector, force the Humanoid to jump Humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end Humanoid:MoveTo(waypoint.Position) Humanoid.MoveToFinished:Wait() -- We reached the waypoint, move on end end) :catch(function(err) -- Computation must've failed, lets see where we went wrong warn(err) end) -- NOTE: You can also use different algorithms for pathfinding: -- Navigator:TryComputePath(RootPart.Position, targetPosition, 10, &quot;Dijkstra&quot;) -- Navigator:TryComputePath(RootPart.Position, targetPosition, 10, &quot;BFS&quot;) -- The &quot;10&quot; param specifies the maximum start/target node query distance, smaller numbers are usually more optimal. end while true do RunPath(workspace.TargetBlock.Position) -- Assuming you have a part called `TargetBlock` in the `Workspace` task.wait(1) end To learn more about the API, visit the API Reference","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"/NodeNavAPI/docs/Examples","content":"Examples Here are some open-source examples of node navigation being used. Mannequin AI Movement for a mannequin AI by @notawildfox similar to the one in the new game DESCENT that moves only when out of line of sight, and has deceleration/acceleration. This example uses Dijkstra's algorithm, because Dijkstra's paths are less &quot;zigzaggy&quot; unlike how A* cost evaluation works --[=[ Makes the entity traverse along a path. @param path NavigatorPath -- The path to traverse along. ]=] type Path = NodeNavigator.Path local pathId = 0 local function TraversePath(path: Path): () -- Get id for interruption when necessary pathId = (pathId + 1) % 1000 local myPath = pathId -- Traverse path local waypoints = path:GetWaypoints() table.remove(waypoints, 1) -- first waypoint is root position, removing it as it bricks the mannequin movement a tiny bit for i, waypoint in waypoints do if pathId ~= myPath then break end if inView then -- We're being observed, freeze. moving = false break end -- Start navigating local targetPosition = waypoint.Position Humanoid:MoveTo(targetPosition) -- Yield until reached repeat task.wait() until (RootPart.Position - targetPosition).Magnitude &lt;= 2 or pathId ~= myPath or inView or not moving end end --[=[ Makes the entity follow its target. ]=] local function MoveToTarget(): () if not target or inView then return end moving = true -- Start accelerating Accelerate() -- Start pathfinding while moving and not inView and target do local otherRootPart = target:FindFirstChild(&quot;HumanoidRootPart&quot;) :: BasePart if not otherRootPart then target = nil moving = false break end -- Compute path from our position to target's current position local success, path = Navigator :TryComputePath(RootPart.Position, otherRootPart.Position, nil, &quot;Dijkstra&quot;) :await() if not success then break end -- Traverse path task.spawn(TraversePath, path) -- Yield until complete or cancelled local nextRecompute = time() + PATH_RECOMPUTE_INTERVAL repeat task.wait() until time() &gt; nextRecompute or not moving or inView end -- Grind to halt Decelerate() moving = false end ","keywords":""},{"title":"Navigator","type":0,"sectionRef":"#","url":"/NodeNavAPI/api/Navigator","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#functions","content":" "},{"title":"Parse​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#Parse","content":"&lt;/&gt; Navigator.Parse( self: Navigator, nodeGraph: NodeGraph-- The new node graph. ) → () Changes the navigator's graph, rebuilding the grid.  "},{"title":"TryComputePath​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#TryComputePath","content":"&lt;/&gt; Navigator.TryComputePath( self: Navigator, startPoint: Vector3 ,-- The pathfinding origin. targetPoint: Vector3 ,-- The pathfinding destination. maxNodeDist: number?,-- The longest sightline to the nearest node the bot will try and find (Leave nil to default to 100) algorithm: &quot;AStar&quot; | &quot;Dijkstra&quot; | &quot;BFS&quot; | &quot;GBFS&quot;?-- Whether to use A* algorithm, Dijkstra's algorithm, Breadth-First Search algorithm, or Greedy Best First Search algorithm for pathfinding. (Leave nil to default to &quot;AStar&quot;) ) → Promise&lt;NavigatorPath&gt;-- The computed path object. Tries to calculate a path from startPoint to targetPoint. If there is no feasible path from startPoint to targetPoint, this function will return nil. Example Usage: navigator:TryComputePath(HumanoidRootPart.Position, target.Position):andThen(function(path) -- Show the computed path to the target path:Visualize() end):catch(warn)  "},{"title":"Errors","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator##","content":"Type\tDescription&quot;No network bound. Did you forget to call :Parse()?&quot;\tA node graph wasn't parsed.  "},{"title":"GetEdgeNear​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#GetEdgeNear","content":"&lt;/&gt; Navigator.GetEdgeNear( self: Navigator, position: Vector3 ,-- Where to look for a nearby edge. maxRadius: number?,-- The maximum distance to check for nearby edges. Default = 100 filterFn: (edge: Edge) → boolean-- An optional edge-by-edge filtering function, where if the returned condition is false, that closest edge will not be considered. ) → Edge?-- The nearest edge Finds and returns the nearest edge to position. This is useful if you wish to disable pathfinding through obstructed areas, for example, debris. Example Usage: local edge = Navigator:GetEdgeNear(position, 10) edge.SetEnabled(false) -- Don't allow pathfinding at this specific edge tip This only returns the closest edge to position within maxRadius. If you want a more accurate detection, use Navigator:GetEdgesInBox() instead.  "},{"title":"GetEdgesInBox​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#GetEdgesInBox","content":"&lt;/&gt; Navigator.GetEdgesInBox( self: Navigator, box: BasePart | BoxParam,-- The param for spatial querying filterFn: (edge: Edge) → boolean-- An optional edge-by-edge filtering function, where if the returned condition is false, that in-box edge will not be appended. ) → {Edge}-- The edges in the specified box region Finds and returns the edges inside of a part or given bounds. This is useful if you wish to disable pathfinding through obstructed areas, for example, debris. Example Usage: for _,edge in Navigator:GetEdgesInBox(edgeDisableRegion) do edge.SetEnabled(false) -- Don't allow pathfinding through `edgeDisableRegion` end   "},{"title":"ConnectNodes​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#ConnectNodes","content":"&lt;/&gt; Navigator.ConnectNodes( self: Navigator, startNode: GraphNode,-- The starting node (the order doesn't matter UNLESS it's a one-way edge) targetNode: GraphNode,-- The target node (the order doesn't matter UNLESS it's a one-way edge) connectionType: &quot;Edge&quot; | &quot;Jump&quot; | &quot;OneWay&quot;,-- The type of the connection. isEnabled: boolean?-- An optional boolean that dictates if the edge is initially enabled or not. ) → Edge-- The newly created edge (the main one. Toggling this edge will also toggle the entire edge bidirectionally) Bidirectionally connects two nodes with a specified connection type If the connection type is &quot;OneWay,&quot; the connection will only be unidirectional. tip A good use case for this would be procedural room generation, where you have multiple room prefabs with their own nodegraphs that are individual from the main / primary nodegraph. In this case, you'd go through all of the nodes/connections in the rooms' nodegraphs, and rebuild them on the main nodegraph. Example Usage of what I wrote for HELLMET by Sensei_Developer: -- Get exit node before anything else; dont want to have the exit node as one of the nodes in the room local exitNode = navigator:GetNodesInBox(v.prefabRoom)[1] -- Instantiate room sub-graph onto main nodegraph. This is basically an alt version of the nodegraph parser local roomNodes = {} for _,node in prefabRoom.NodeGraph.Nodes:GetChildren() do if node:IsA(&quot;BasePart&quot;) then -- Keep track of the old node name for building connections on main graph -- This is so that we can refer to the nodes on the main graph with the sub-graph's nodes -- Otherwise there'd be ambiguity, duplicate nodes roomNodes[node.Name] = navigator:PlaceNode(node.Position) end end -- Re-build edges for _,edge in prefabRoom.NodeGraph.Edges:GetChildren() do if edge:IsA(&quot;Constraint&quot;) or edge:IsA(&quot;Beam&quot;) then local delimiter = edge.Name:gmatch(&quot;%d+&quot;) local startId, targetId = delimiter(), delimiter() navigator:ConnectNodes(roomNodes[startId], roomNodes[targetId], GetEdgeType(edge)) end end -- OK, now connect the exiting/entrance nodes -- The exit node is the way in and out of the room pretty much if exitNode then navigator:ConnectNodes(roomNodes[prefabRoom.EnterNode.Value.Name], exitNode) else warn(&quot;Couldnt find exit node&quot;) end -- Now, the AI can pathfind inside and outside of this room.  "},{"title":"Errors","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator##","content":"Type\tDescription&quot;No network bound. Did you forget to call :Parse()?&quot;\tA node graph wasn't parsed.  "},{"title":"PlaceNodeAt​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#PlaceNodeAt","content":"&lt;/&gt; Navigator.PlaceNodeAt( self: Navigator, position: Vector3 ,-- The position of the node. index: string?-- The index/name of the node. If not supplied, will use the next available node index. ) → GraphNode-- The newly created node. Creates a node at a position. tip A good use case for this would be procedural room generation, where you have multiple room prefabs with their own nodegraphs that are individual from the main / primary nodegraph. In this case, you'd go through all of the nodes/connections in the rooms' nodegraphs, and rebuild them on the main nodegraph. Example Usage of what I wrote for HELLMET by Sensei_Developer: -- Get exit node before anything else; dont want to have the exit node as one of the nodes in the room local exitNode = navigator:GetNodesInBox(v.ExitArea)[1] -- Instantiate room sub-graph onto main nodegraph. This is basically an alt version of the nodegraph parser local roomNodes = {} for _,node in v.NodeGraph.Nodes:GetChildren() do if node:IsA(&quot;BasePart&quot;) then -- Keep track of the old node name for building connections on main graph -- This is so that we can refer to the nodes on the main graph with the sub-graph's nodes -- Otherwise there'd be ambiguity, duplicate nodes roomNodes[node.Name] = navigator:PlaceNode(node.Position) end end -- Re-build edges for _,edge in v.NodeGraph.Edges:GetChildren() do if edge:IsA(&quot;Constraint&quot;) or edge:IsA(&quot;Beam&quot;) then local delimiter = edge.Name:gmatch(&quot;%d+&quot;) local startId, targetId = delimiter(), delimiter() navigator:ConnectNodes(roomNodes[startId], roomNodes[targetId], GetEdgeType(edge)) end end -- OK, now connect the exiting/entrance nodes -- The exit node is the way in and out of the room pretty much if exitNode then navigator:ConnectNodes(roomNodes[v.EnterNode.Value.Name], exitNode) else warn(&quot;Couldnt find exit node&quot;) end -- Now, the AI can pathfind inside and outside of this room.  "},{"title":"Errors","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator##","content":"Type\tDescription&quot;No network bound. Did you forget to call :Parse()?&quot;\tA node graph wasn't parsed.  "},{"title":"GetNodeWithIndex​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#GetNodeWithIndex","content":"&lt;/&gt; Navigator.GetNodeWithIndex( self: Navigator, index: string-- The index of the node to find ) → GraphNode?-- The node with the matching index Finds a node with a specified index/name. Useful if you want to seek two nodes and connect them together. "},{"title":"Errors","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator##","content":"Type\tDescription&quot;No network bound. Did you forget to call :Parse()?&quot;\tA node graph wasn't parsed. &quot;Invalid index (expected string, got {X})&quot;\tIndex MUST be a string.  "},{"title":"GetNodeNear​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#GetNodeNear","content":"&lt;/&gt; Navigator.GetNodeNear( self: Navigator, position: Vector3 ,-- Where to look for a nearby node. maxRadius: number?,-- The maximum distance to check for nearby node. Default = 100 filterFn: (node: GraphNode) → boolean-- An optional node-by-node filtering function, where if the returned condition is false, that closest node will not be considered. ) → GraphNode?-- The nearest node Finds and returns the nearest node to position.  "},{"title":"GetNodesInBox​","type":1,"pageTitle":"Navigator","url":"/NodeNavAPI/api/Navigator#GetNodesInBox","content":"&lt;/&gt; Navigator.GetNodesInBox( self: Navigator, box: BasePart | BoxParam,-- The param for spatial querying filterFn: (node: GraphNode) → boolean-- An optional node-by-node filtering function, where if the returned condition is false, that in-box node will not be appended. ) → {GraphNode}-- The nodes in the specified box region Finds and returns the nodes inside of a part or given bounds. "}]